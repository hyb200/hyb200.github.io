[{"title":"为什么 TCP 是三次握手？","path":"/2024/05/06/为什么 TCP 是三次握手？/","content":"为什么 TCP 连接需要三次握手，不是两次，四次？ 基本原因：三次握手才能保证通信双方具备接收和发送的能力 下面分别展开深入分析。 使用三次握手的原因 阻止重复历史连接的初始化，避免资源浪费 同步双方的初始序列号，保证双方都具备接发的能力 避免历史连接 客户端希望与服务器建立连接，但是由于网络堵塞，发送了多个 SYN 报文： 旧的 SYN 报文（seq=90）先到达服务器，服务器返回 SYN+ACK 报文（ACK=91） 客户端期望收到的 ACK=101，不是 91，发送 RST 报文 服务器收到 RST 报文后，释放连接 等到最新的 SYN 报文（seq=100）到达服务器，正常进行三次握手 旧 SYN 报文成为历史连接。 使用两次握手？使用两次握手无法避免历史连接 假定使用两次握手，当服务器接收到一个 SYN 报文就建立连接，接下来可以发送数据。但是它不知道这是历史连接。当客户端感知到这是历史连接时，就会发送 RST 报文断开连接。这样会浪费服务器的资源。 使用四次握手？ 使用四次握手也能成功建立连接，但是第二步和第三步可以合并为一步，就变成了三次握手。"},{"title":"JS 高阶函数与函数柯里化","path":"/2024/05/05/JS 高阶函数与函数柯里化/","content":"高阶函数如果一个函数符合下面两个规范中的任何一个，那该函数就是高阶函数。 函数接收的参数是一个函数 函数调用后的返回值依然是一个函数 常见的高阶函数：Promise、setTimeout、arr.map() 等等 函数的柯里化通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式 1234567function sum(a) {\treturn (b) =&gt; { return (c) =&gt; { return a + b + c; }\t}}","tags":["JavaScript"]},{"title":"如何保证数据库和缓存的一致性","path":"/2024/05/05/如何保证数据库和缓存的一致性/","content":"先更新数据库，还是先更新缓存？当我们引入了缓存之后，在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在先后的问题。但在并发环境下，无论哪个先更新，都不能保证数据库和缓存的一致性。一般建议使用「先更新数据库，再删除缓存」的方案。 如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况。 针对并发导致的一致性问题，有两种解决方案： 在更新缓存前加个分布式锁，确保同一时间只有一个请求更新缓存。（会影响性能） 在更新缓存时给缓存加上较短的过期时间，即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务也能够接受。 Cacha Aside 旁路策略在更新数据时，不更新缓存，而是删除缓存中的数据。之后在读数据的时候，发现缓存中没有对应的数据，就去查数据库，并且更新到缓存中。 旁路策略可以细分为读策略和写策略： 写策略的步骤： 更新数据库 删除缓存 读策略的步骤： 如果读取的数据命中缓存，则直接返回数据 如果读取的数据没有命中，则从数据库中读取数据，然后将数据写入缓存，返回给用户 先删除缓存，再更新数据库假设请求 A 需要更新数据库，先删除缓存。这时请求 B 读取该数据，查询缓存没命中，从数据库读取到数据并且回写进缓存，然后请求 A 继续修改数据库，将对应数据更新。这时缓存和数据库中的数据不一致。 解决方案：延迟双删，请求 A 在更新完数据库后睡眠一段时间后再次删除缓存，确保请求 B 在 A 睡眠时间内完成所以操作 先更新数据库，再删除缓存假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中，出现缓存和数据库不一致的情况。 在实际中，缓存的写入远远快于数据库的写入，这个问题出现概率不大。可以给缓存加上过期时间来作为兜底策略。 删除缓存而不是更新缓存，是系统设计中懒加载思想的一个应用"},{"title":"React 学习笔记","path":"/2024/05/03/React 学习笔记/","content":"React 的特点 声明式编码 组件化编码 React Native 编写原生应用 高效（优秀的Diffing算法） React 为什么高效？ 使用了虚拟 DOM，不总是直接操作页面真是 DOM DOM Diffing 算法，最小化页面重绘 虚拟 DOM 与真实 DOM虚拟 DOM 本质上是一个 Object 对象，最终会被 React 转换为真实 DOM，渲染到界面上。 虚拟 DOM 比较轻量。 两种方式创建虚拟 DOM使用原生 JS(不推荐）： 1const VDOM = React.createElement('h1', {id: 'title'}, 'hello world') 使用 JSX（会通过 Babel 转化为 JS）： 1const VDOM = &lt;h1 id='title'&gt;hello world&lt;/h1&gt; 渲染虚拟 DOM将虚拟 DOM 渲染到页面中的真实容器 DOM 里 1React.render(VDOM, containerDOM) JSX 语法规则 定义虚拟DOM时，不用写引号 标签中混入JS表达式时要用{} 样式的类名指定要用 className 内联样式要用 style = {{key:value}} 的形式，使用驼峰命名法 虚拟 DOM 只能有一个根标签 标签必须闭合 标签首字母 小写字母开头，则将该标签转为 html 中的同名元素 大写字母开头，React 渲染对应的组件 面向组件编程函数式组件12345function Demo() {\treturn &lt;h2&gt;这是函数式组件&lt;/h2&gt;}// 注意 render 传的是组件标签ReactDOM.render(&lt;Demo/&gt;, document.getElementById(\"test\")); 类式组件类式组件必须继承 React.Component ，且具有 render() 方法 123456class Demo extends React.Component {\trender() { return &lt;h2&gt;这是类式组件&lt;/h2&gt;\t}}ReactDOM.render(&lt;Demo/&gt;, document.getElementById(\"test\")); 原理： 当执行 ReactDOM.render(&lt;Demo/&gt;.......) 之后，React 解析组件标签，找到了 Demo 组件。发现组件是使用类定义的，随后 new 出来该类的实例，并通过该实例调用到原型上的 render 方法。将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。 组件实例的三大核心属性statestate 属性用来表示组件的状态 state 属性只能通过 setState 函数更改，会与原先的 state 合并 state 示例1234567891011121314151617181920212223class Weather extends React.Component {\tconstructor(props) { super(props); // 初始化 state this.state = { isHot: true }; this.change = this.change.bind(this);\t}\trender() { const { isHot } = this.state; return ( // onClick 绑定事件，注意要使用驼峰命名法 &lt;h2 onClick={this.change}&gt; 今天天气：{this.state.isHot ? \"hot\" : \"cold\"} &lt;/h2&gt; );\t}\tchange() { // change 方法放在 Weather 的原型对象上 const isHot = this.state.isHot; this.setState({ isHot: !isHot });\t}}ReactDOM.render(&lt;Weather /&gt;, document.getElementById(\"test\")); 构造器中的 this 指向当前类的示例对象，render 方法通过类的实例调用，方法中的 this 也只想当前类的实例对象。 change 方法作为 onClick 的回调，并不是由类的实例调用，是直接调用。类中定义的方法自动开启了局部严格模式，故 this 为 undefined 可以通过 bind 函数将当前实例对象绑定到 change 上 state 的简写方式（推荐）一般类组件中的自定义方法（除了 render）是作为回调函数调用的，可以将方法写成赋值语句+箭头函数的形式。箭头函数会找它外层函数的 this 作为它本身的 this。 12345678910111213141516171819class Weather extends React.Component {\t// 初始化状态\tstate = {isHot: true} render() { const { isHot } = this.state; return ( &lt;h2 onClick={this.change}&gt; 今天天气：{this.state.isHot ? \"hot\" : \"cold\"} &lt;/h2&gt; );\t} change = () =&gt; { const isHot = this.state.isHot; this.setState({ isHot: !isHot });\t}}ReactDOM.render(&lt;Weather /&gt;, document.getElementById(\"test\")); props用于向组件传递数据，是只读的。 类式组件使用 props1234567891011121314151617181920212223242526class Person extends React.Component {\trender() { const { name, age, sex } = this.props; return ( &lt;ul&gt; &lt;li&gt;name: {name}&lt;/li&gt; &lt;li&gt;sex: {sex}&lt;/li&gt; &lt;li&gt;age: {age}&lt;/li&gt; &lt;/ul&gt; );\t}\t// 使用 static，给类添加属性\tstatic propTypes = { name: PropTypes.string.isRequired, // isRequired: 必需 age: PropTypes.number, sex: PropTypes.string, speak: PropTypes.func, // func: 函数\t};\t// 设定默认值\tstatic defaultProps = { name: \"ikun\",\t}; }ReactDOM.render(&lt;Person sex=\"0\" age={20}/&gt;, document.getElementById(\"test\")); 类式组件的构造器是否接收 props，是否传递给 super，取决于是否希望在构造器中通过 this 访问 props。一般情况下都不写构造器。 函数式组件使用 props函数式组件通过接收参数来传递 props 123456789101112131415161718192021222324function Person(props) {\tconst { name, sex, age } = props;\treturn ( &lt;ul&gt; &lt;li&gt;name: {name}&lt;/li&gt; &lt;li&gt;sex: {sex}&lt;/li&gt; &lt;li&gt;age: {age}&lt;/li&gt; &lt;/ul&gt;\t);}// 给组件添加属性Person.propTypes = {\tname: PropTypes.string.isRequired, // 必需\tage: PropTypes.number,\tsex: PropTypes.string,\tspeak: PropTypes.func,};// 设定默认值Person.defaultProps = {\tname: \"ikun\",};ReactDOM.render(&lt;Person sex=\"0\" age={20} /&gt;,document.getElementById(\"test\")); refs 与事件处理ref 用来标识某个标签，相当于原生标签中的 id，可以通过 this.refs 来获取到对应的真实 DOM 字符串形式的 ref存在效率问题，不推荐使用 12345678910111213141516class Demo extends React.Component {\tshow = () =&gt; { const {input} = this.refs; alert(input.value);\t}; render() { return ( &lt;div&gt; &lt;input ref=\"input\" type=\"text\" /&gt; &amp;nbsp; &lt;button onClick={this.show}&gt;click&lt;/button&gt; &lt;/div&gt; );\t}} 回调形式的 refref 传入一个回调函数，回调函数的参数就是当前 DOM 节点，React 会自动调用该回调函数，将该节点挂载到实例对象上。 12345678910111213141516class Demo extends React.Component {\tshow = () =&gt; { const {input} = this; alert(input.value);\t}; render() { return ( &lt;div&gt; &lt;input ref={c =&gt; this.input = c } type=\"text\" /&gt; &amp;nbsp; &lt;button onClick={this.show}&gt;click&lt;/button&gt; &lt;/div&gt; );\t}} 关于回调 refs 的说明如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 使用 createRef使用 React.createRef API 来创建一个容器，该容器可以存储被 ref 所标识的节点，一个容器只能放一个节点 1234567891011121314151617class Demo extends React.Component {\tmyRef = React.createRef(); show = () =&gt; { alert(this.myRef.current.value);\t}; render() { return ( &lt;div&gt; &lt;input ref={this.myRef} type=\"text\" /&gt; &amp;nbsp; &lt;button onClick={this.show}&gt;click&lt;/button&gt; &lt;/div&gt; );\t}} 注意事项避免过度使用 ref，建议使用受控组件，类似 Vue 中的双向绑定。 1234567891011class Demo extends React.Component {\tstate = { info: \"\" }; saveInfo = (e) =&gt; { this.setState({info: e.target.value})\t}\t// 通过onChange 将数据及时更新到 state 中\trender() { return &lt;input onChange={this.saveInfo} type=\"text\" /&gt;;\t}} 生命周期React 组件中包含一系列生命周期回调函数，会在特定的时刻调用 static getDerivedStateFromProps1static getDerivedStateFromProps(props, state) 从 props 中获得派生的状态，适用于 state 值在任何时候都取决于 props，一般不建议使用。 getSnapshotBeforeUpdate1getSnapshotBeforeUpdate(prevProps, prevState) 在最近一次渲染输出之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息。其返回值将作为参数传递给 componentDidUpdate()","tags":["React"]},{"title":"Java Comparator 接口的使用","path":"/2024/04/30/Java Comparator 接口的使用/","content":"很多情况下，我们需要对一个数组进行自定义排序，就可以使用 Comparator 接口。 Comparator 接口Comparator 接口的定义以及常用的方法如下： 123public interface Comparator&lt;T&gt; {\tint compare(T o1, T o2);} compare 方法用来比较两个对象的顺序，方法返回值有 3 种情况： o1 &lt; o2：返回 -1 o1 == o2：返回 0 o1 &gt; 02：返回 1 当返回结果为正数时，需要交换 o1，o2 的次序 示例使用 Comparator 接口对数组排序 1234567public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(3, 1, 2, 99, -1); // 使用了 lambda 表达式，从大到小排序 list.sort((a, b) -&gt; b - a); System.out.println(list); }// [99, 3, 2, 1, -1]","tags":["Java"]},{"title":"小破站装修日记","path":"/2024/04/28/小破站装修日记/","content":"心路历程从上大学到现在，经历了两次电脑硬盘损坏，东西全部丢失，心态崩了。回想起我以前的存储习惯，并没有很好地整理和备份我的文档和资料。因此，我下定决心要改掉这个坏习惯，走出自己的舒适区，才能进步。 时间线 2024年4月29日 我的小破站终于成功上线了，并且利用 Github Action 实现了自动部署，同时将我的博客文档全都托管在 Github 仓库。小破站的主题是 stellar ，示例看起来非常不错，虽然当前的小破站还是毛坯房，等看看啥时间有空再来装修一下吧 hh。"}]