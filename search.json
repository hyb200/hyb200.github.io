[{"title":"服务端向 Web 端推送方案设计","path":"/2024/05/25/服务端向 Web 端推送方案设计/","content":"有很多场景需要服务端主动向客户端推送消息，比如小红点提醒，新消息提醒，群聊等场景，本文档记录服务端推送消息的方案以及简单实现。 方案设计1、短轮询前端不断间隔一段事件向服务器发送一个 HTTP 请求，如果有数据，就会在某次请求中返回。 适用场景： 扫码登录：短时间内频繁查询二维码状态 小OA系统：客户端使用量不大的情况下可以使用 缺点： 大量无效请求：大量的无效请求，浪费服务器资源 服务端请求压力大：万人群聊频繁访问，上万并发服务扛不住 2、长轮询长轮询和短轮询相比，一个最大的改进之处在于： 短轮询模式下，服务端不管本轮有没有新消息产生，都会马上响应并返回。而长轮询模式当本次请求没有获取到新消息时，并不会马上结束返回，而是会在服务端“悬挂（hang）”，等待一段时间； 如果在等待的这段时间内有新消息产生，就能马上响应返回。 这也意味着 web 端的请求超时时长需要设置长一些。 相比短轮询模式，大幅降低短轮询模式中客户端高频无用的轮询导致的网络开销和功耗开销。 缺点： 长轮询在超时时间内没有获取到消息时，会结束返回，因此仍然没有完全解决客户端“无效”请求的问题。 服务端压力大：服务端悬挂（hang）住请求，只是降低了入口请求的 QPS，并没有减少对后端资源轮询的压力。假如有 1000 个请求在等待消息，可能意味着有 1000 个线程在不断轮询消息存储资源。（轮询转移到了后端） 3、WebSocket长轮询和短轮询都是由客户端先发起的请求，服务端无法主动推送消息，因此诞生了 WebSocket。 实现原理： 客户端和服务器之间维持一个 TCP/IP 长连接，全双工通道 Netty 实现 WebSocket123456789101112131415161718192021222324252627282930313233// 初始化 ChannelPipeline import com.abin.handler.HttpRequestHandler; import com.abin.handler.TextWebSocketFrameHandler; import io.netty.channel.Channel; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.group.ChannelGroup; import io.netty.handler.codec.http.HttpObjectAggregator; import io.netty.handler.codec.http.HttpServerCodec; import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler; import io.netty.handler.stream.ChunkedWriteHandler; public class ChatServerInitializer extends ChannelInitializer&lt;Channel&gt; { private final ChannelGroup group; public ChatServerInitializer(ChannelGroup group) { this.group = group; } @Override protected void initChannel(Channel channel) throws Exception { ChannelPipeline pipeline = channel.pipeline(); pipeline.addLast(new HttpServerCodec()); pipeline.addLast(new ChunkedWriteHandler()); // http 数据在传输过程中是分段的 // HttpObjectAggregator可以把多个段聚合起来； pipeline.addLast(new HttpObjectAggregator(64 * 1024)); pipeline.addLast(new HttpRequestHandler(\"/ws\")); pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\")); pipeline.addLast(new TextWebSocketFrameHandler(group)); } } WebSocketServerProtocolHandler 处理了所有委托管理的 WebSocket 帧类型以及升级握手本身。如果握手成功，那么所需的 ChannelHandler 将会被添加到 ChannelPipeline 中，而那些不再需要的 ChannelHandler 则将会被移除。"},{"title":"Git 项目推送","path":"/2024/05/14/Git 项目推送/","content":"Git 如何将项目推送到远程仓库？ 1. 远程仓库没有文件 git init git remote add origin &lt;地址&gt; git add . git commit -m \"\" git push 2. 远程仓库有文件 git init git remote add origin &lt;地址&gt; git pull origin branch_name git branch --set-upstream-to=origin/main main git add . git commit -m \"\" git push -u origin","tags":["Git"]},{"title":"Java 的 IO 模型","path":"/2024/05/14/Java 的 IO 模型/","content":"本文介绍 Java 的 3 种 IO 模型 何为 I/O？I/O 描述了计算机系统与外部设备之间的通信过程。用户进程需要执行 IO 操作的话，需要通过系统调用来访问内核空间，即具体 IO 的执行由操作系统的内核来完成。 平常接触最多的是磁盘 IO（读写文件）和网络 IO（网络请求和响应） 当程序发起 I/O 调用后，会经历两个步骤： 内核等待 I/O 设备准备好数据 内核将数据从内核空间拷贝到用户空间 UNIX 系统下， IO 模型一共有 5 种：同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。 同步非阻塞 I/O：一直调用 read 请求数据，如果没有数据会直接返回，直到数据准备好了。在等待数据过程中，会频繁在用户态和内核态之间切换。 Java 中 3 种常见的 IO 模型BIOBIO 属于同步阻塞 IO 模型 同步阻塞 IO 模型中，应用进程在发起 IO 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。 stream 相关的 API 都是阻塞的 NIONIO 是支持面向缓冲的，基于通道的 IO 操作方法。Java 中的 NIO 是 I/O 多路复用模型。 IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。 IO 多路复用模型，减少无用的系统调用，降低了对 CPU 资源的消耗。 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。 select 调用：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。 epoll 调用：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。 使用 NIO 不一定意味着高性能，其性能优势体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO。 三大组件三大组件包括 Channel、Buffer、Selector Channel用于读写数据的双向通道，可以从 channel 中读取数据到 buffer，也可以将 buffer 的数据写入 channel。 常用的 Channel 有： FileChannel：文件传输通道 DatagramChannel：UDP 传输通道 SocketChannel、ServerSocketChannel：TCP 传输通道 Buffer用于缓冲读写数据，常用的是 ByteBuffer ByteBuffer 食用示例： 1234567891011121314151617try (FileChannel channel = new FileInputStream(\".\\\\data.txt\").getChannel()) { // 准备缓冲区 ByteBuffer buffer = ByteBuffer.allocate(5); int len; // 从 channel 中读取数据，向 buffer 写入 while ((len = channel.read(buffer)) != - 1) { buffer.flip(); // 切换到读模式 while (buffer.hasRemaining()) { // 是否还有剩余未读数据 byte b = buffer.get(); // 从 buffer 中读数据 System.out.println(\"Get character from buffer \" + (char) b); } buffer.clear(); // 切换到写模式 } } catch (IOException e) { e.printStackTrace(); } Buffer 结构Buffer 中有三个重要的属性：capacity、position、limit。有两种模式：读模式和写模式。Buffer 被创建之后默认是写模式，调用 flip() 可以切换到读模式。如果要再次切换回写模式，可以调用 clear() 或者 compact() 方法。 默认状态： 写入 4 个字节的状态： 调用 flip() 方法，position 移到读取位置，limit 切换到读取限制： 调用 clear() ，回到默认状态；调用 compact()，把未读完的向前移，切换到写模式： Seletor用来配合一个线程管理多个 Channel，获取这些 Channel 上发生的事件。 一个多路复用器 Selector 可以同时轮询多个 Channel，底层 JDK 使用了 epoll() 调用。 在注册 Channel 到 Selector 上时，同时需要 Channel 添加独立的 Buffer。将 Channel 注册到 Selector 上，会返回一个 SelectionKey，用来标识某个 Channel，并且会监听该 Channel 上的事件，如 accept、connect、read、write。不同类型的 Channel 关注的事件不同，需要给 SelectionKey 绑定关注的事件。当没有事件发生时，线程会阻塞。 select 方法，没有事件发生时线程阻塞，有事件发生才会恢复运行。在事件未处理时，线程不会阻塞，因此事件要么处理，要么取消，否则线程会陷入死循环。 selector 在事件发生后，会向 selectedKeys 集合中加入对应的 key，但不会主动删除，因此处理完某个 key 应该主动移除，防止 NPE。因为涉及到删除操作，应该使用迭代器遍历 零拷贝零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。 传统的 IO 问题假设我们现在需要将一个文件通过 socket 写出，伪代码如下： 12345678File f = new File(\"data.txt\");RandomAccessFile file = new RandomAccessFile(file, \"r\");byte[] buf = new byte[(int)f.length()];file.read(buf);Socket sc = ...;sc.getOutputStream().write(buf); 内部的工作流程如下图： 调用 read 方法后，程序会从用户态切换到内核态，由内核将数据读到内核缓冲区，这时候用户线程阻塞，CPU 不参与 从内核态切换会用户态，将数据从内核缓冲区拷贝到用户缓冲区（即buf），此时 CPU 参与拷贝 将数据从用户缓冲区写入 socket 缓冲区，CPU 参与拷贝 从用户态切换到内核态，调用内核将 socket 缓冲区中的数据写入网卡，CPU 不参与 以上过程经历 4 次上下文的切换和 4 次数据拷贝 mmap 优化 使用内存映射，将堆外内存映射到 JVM 内存，减少了一次数据的拷贝。用户态与内核态的切换次数没有减少 堆外内存不受 GC 的影响，因此内存地址固定，有助于IO 读写 java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步 DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列 通过专门线程访问引用队列，根据虚引用释放堆外内存 sendFile 优化 将数据读到内核缓冲区后，无需切换回 Java，直接可以将数据复制到 socket 缓冲区，数据拷贝了 3 次，上下文切换 2 次 Java 调用 transferTo 方法后，从用户态切换至内核态，使用 DMA 将数据读入内核缓冲区，不会使用 cpu 数据从内核缓冲区传输到 socket 缓冲区，cpu 会参与拷贝 最后使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu sendFile + DMA gather copy 将数据读到内核缓冲区后，通过 DMA 直接将数据发送到网卡，整个过程不需要 CPU 的参与，数据拷贝了 2 次，上下文切换 2 次。 Java 调用 transferTo 方法后，从用户态切换至内核态，使用 DMA 将数据读入内核缓冲区，不会使用 cpu 只会将一些 offset 和 length 信息拷入 socket 缓冲区，几乎无消耗 使用 DMA 将内核缓冲区的数据写入网卡，不会使用 cpu AIOAIO 即 NIO2，是异步 IO 模型 异步 IO 是基于事件和回调机制实现。应用操作之后会直接返回，不会造成阻塞，当后台处理完成后操作系统会通知响应的线程进行后续操作"},{"title":"Netty 修炼之路","path":"/2024/05/14/Netty 修炼之路/","content":"Netty 是一个异步的、基于事件驱动的高性能网络应用框架，本文档维护 Netty 的相关内容。 一些概念Netty 的基础构件块：Channel、回调、Future、事件及 ChannelHandler Channel ：数据的通道，一个到实体的开放连接 Future ：一种在操作完成时通知应用程序的方式。 ChannelFuture用于在执行异步操作的时候使用，可以注册一个或多个监听器，提供回调方法，这些方法将会在之后某个时间点执行 事件：用来通知状态的改变或者是操作的状态 入站相关 连接已被激活或者连接失活 数据读取 用户事件 错误事件 出站相关 打开或关闭到远程节点的连接 将数据写到或冲刷到套接字 每个事件都可以被分发给 ChannelHandler 类中的某个用户实现的方法 Netty 通过触发事件将 Selector 从应用程序中抽象出来。在内部，将会为每个 Channel分配一个 EventLoop，用以处理所有事件 msg ： 流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，后输出又变成 ByteBuf handler ：数据的处理工序 多个工序合在一起就是 pipeline，pipeline 负责将事件传播给每个 handler， handler 对自己感兴趣的事件进行处理 handler 分 Inbound（入站）和 Outbound（出站） 两类 eventLoop ：处理数据的工人 工人可以管理多个 channel 的 IO 操作，工人和 channel 是绑定在一起的 工人既可以执行 IO 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务 工人按照 pipeline 顺序，依次按照 handler 的规划处理数据，可以为每道工序指定不同的工人 基础示例Server 端要实现一个服务器，主要有以下步骤： 创建一个 ServerBootstrap 的实例以引导和绑定服务器 创建并分配一个 NioEventLoopGroup 实例以进行事件的处理，如接受新连接以及读/ 写数据 指定服务器绑定的本地的 InetSocketAddress 使用一个 EchoServerHandler 的实例初始化每一个新的 Channel 调用 ServerBootstrap.bind() 方法以绑定服务器。 123456789101112131415161718192021private void start() throws InterruptedException { final EchoServerHandler serverHandler = new EchoServerHandler(); NioEventLoopGroup group = new NioEventLoopGroup(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(group) .channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { ch.pipeline().addLast(serverHandler); } }); ChannelFuture future = serverBootstrap.bind().sync(); future.channel().closeFuture().sync(); } catch (Exception e) { throw new RuntimeException(e); } finally { group.shutdownGracefully().sync(); } Client 端客户端实现步骤： 创建一个 Bootstrap 实例 为进行事件处理分配了一个 NioEventLoopGroup 实例，其中事件处理包括创建新的连接以及处理入站和出站数据 为服务器连接创建了一个 InetSocketAddress 实例 当连接被建立时，一个 EchoClientHandler 实例会被安装到该 Channel 的 ChannelPipeline 中 在一切都设置完成后，调用 Bootstrap.connect() 方法连接到远程节点 123456789101112131415161718192021private void start() throws InterruptedException { NioEventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { ch.pipeline().addLast(new EchoClientHandler()); } }); ChannelFuture f = bootstrap.connect().sync(); f.channel().closeFuture().sync(); } catch (Exception e) { throw new RuntimeException(e); } finally { group.shutdownGracefully().sync(); } } 组件与设计Channel、EventLoop 和 ChannelFuture Channel – Socket Channel 的生命周期状态如下表： 状态 描述 ChannelUnregistered Channel 已经被创建，但还未注册到 EventLoop ChannelRegistered Channel 已经被注册到了 EventLoop ChannelActive Channel 处于活动状态，可以接收和发送数据 ChannelInactive Channel 没有连接到远程节点 EventLoop – 控制流、多线程、并发 ChannelFuture – 回调， 异步通知 一个 EventLoopGroup 包含一个或者多个 EventLoop 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理 一个 Channel 在它的生命周期内只注册于一个 EventLoop 一个 EventLoop 可能会被分配给一个或多个 Channel 在 Netty 的设计中，一个 Channel 的所有操作都由相同的 Thread 执行，消除了同步的需要。是线程安全的。 Netty 提供了 ChannelFuture 接口，其 addListener() 方法注册了一个 ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知 ChannelHandler 和 ChannelPipelineChannelHandler 是 Netty 中最主要的组件，用于处理入站和出站数据，由网络事件触发。常用的是 ChannelInboundHandler 接口。 ChannelPipeline 是 ChannelHandler 的实例链。每一个新创建的 Channel 都将会被分配一个新的 ChannelPipeline。某个 ChannelHandler 在处理完某个事件后，会将数据按顺序传递给链中的下一个 ChannelHandler。 出站和入站？从客户端的角度来讲，事件运动方向从客户端到服务器端，则为出站，反之为入站。 当 ChannelHandler 被添加到 ChannelPipeline 时 ，它将会被分配一个 ChannelHandlerContext，其代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。这个对象主要被用于写出站数据，是不同 ChannelHandler 交互的媒介。 ChannelPipeline 可以根据需要，通过添加或者删除 ChannelHandler 来动态地修改 ChannelPipeline 有着丰富的 API 用以被调用，以响应入站和出站事件。 ChannelHandlerContext 有很多的方法，其中一些方法也存在于 Channel 和 ChannelPipeline 本身上，但是有一点重要的不同。如果调用 Channel 或者 ChannelPipeline 上的这些方法，它们将沿着整个 ChannelPipeline 进行传播。 调用位于 ChannelHandlerContext 上的相同方法，则将从当前所关联的 ChannelHandler 开始，并且只会传播给位于该 ChannelPipeline 中的下一个能够处理该事件的 ChannelHandler。 如果需要在多个 ChannelPipeline 上共享同一个 ChannelHandler，需要加上 @Sharable 注解，常用于需要跨越多个 Channel 收集信息的场景，注意共享 ChannelHandler 需要处理同步问题。 ByteBufByteBuf 是 Netty 的数据处理容器 优点： 可以被用户自定义的缓冲区类型扩展 通过内置的复合缓冲区类型实现了透明的零拷贝 容量可以按需增长 在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip() 方法 读和写使用了不同的索引 支持方法的链式调用 支持引用计数 支持池化 工作原理ByteBuf 维护两个索引，一个用于读取 readerIndex，一个用于写入 writerIndex。如果两个索引值相同，说明达到了“可读数据”的末尾。 名称以 read 或者 write 开头的 ByteBuf 方法，将会推进其对应的索引，而名称以 set 或者 get 开头的操作则不会。后面的这些方法将在作为一个参数传入的一个相对索引上执行操作。 使用模式1. 堆缓冲区 将数据存储在 JVM 的堆中，能在没有使用池化的情况下提供快速的分配和释放。 2. 直接缓冲区 直接缓冲区的内容在堆外内存，对于网络数据传输是理想的选择。如果需要处理这部分的数据，需要将其复制到工作内存中。 3. 复合缓冲区 为多个 ByteBuf 提供一个聚合视图。CompositeByteBuf 实现该模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。 分配 ByteBuf1. 按需分配：ByteBufAllocator 接口 ByteBufAllocator 实现了 ByteBuf 的池化。 Netty 提供了两种 ByteBufAllocator 的实现：PooledByteBufAllocator 和 UnpooledByteBufAllocator。前者池化了 ByteBuf 的实例以提高性能并最大限度地减少内存碎片。后者的实现不池化 ByteBuf 实例，并且在每次它被调用时都会返回一个新的实例。 2. Unpooled 缓冲区 Unpooled 工具类提供了静态的辅助方法来创建未池化的 ByteBuf 实例。 3. ByteBufUtil 类 ByteBufUtil 提供了用于操作ByteBuf的静态的辅助方法。 异常处理入站异常处理每个 Channel 都拥有一个与之相关联的 ChannelPipeline，其持有一个 ChannelHandler 的实例链。在默认的情况下，ChannelHandler 会把对它的方法的调用转发给链中的下一个 ChannelHandler。因此，如果 exceptionCaught() 方法没有被该链中的某处实现，那么所接收的异常将会被传递到 ChannelPipeline 的尾端并被记录。为此，你的应用程序应该提供至少有一个实现了 exceptionCaught() 方法的ChannelHandler。 ChannelHandler.exceptionCaught() 默认将当前异常转发给 ChannelPipeline 中的下一个 ChannelHandler 如果异常到达了 ChannelPipeline 的尾端，它将会被记录为未被处理 可以重写 exceptionCaught() 方法来自定义处理逻辑 出站异常处理 每个出站操作都将返回一个 ChannelFuture。注册到 ChannelFuture 的 ChannelFutureListener 将在操作完成时被通知该操作是成功了还是出错了 几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise 的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。 ChannelPromise 还具有提供立即通知的可写方法 ChannelPromise setSuccess(); ChannelPromise setFailure(Throwable cause); EventLoop 和线程模型1. 异步传输 EventLoopGroup 负责为每个新创建的 Channel 分配一个 EventLoop。在当前实现中， 使用轮询的方式进行分配以获取一个均衡的分布，并且相同的 EventLoop 可能会被分配给多个 Channel。 一旦一个 Channel 被分配给一个 EventLoop，它将在它的整个生命周期中都使用这个 EventLoop（以及相关联的Thread）。 另外，需要注意的是，EventLoop 的分配方式对 ThreadLocal 的使用的影响。因为一个 EventLoop 通常会被用于支撑多个 Channel，所以对于所有相关联的 Channel 来说， ThreadLocal 都将是一样的。这使得它对于实现状态追踪等功能来说是个糟糕的选择。然而， 在一些无状态的上下文中，它仍然可以被用于在多个 Channel 之间共享一些重度的或者代价昂贵的对象，甚至是事件。 2. 阻塞传输 每一个 Channel 都将被分配给一个 EventLoop（以及它的 Thread）。每个 Channel 的I/O 事件都将只会被一个 Thread （用于支撑该 Channel 的 EventLoop 的那个 Thread）处理。 消息的资源管理write()：不会释放消息 writeAndFlash()：消息会在该方法被调用时释放"},{"title":"Java 线程池的那些事","path":"/2024/05/12/Java 线程池的那些事/","content":"本文章目标是介绍 Java 线程池的相关基础知识 线程池的状态线程池一共有 5 种状态。分别是 RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED 状态 含义 RUNNING 接受新任务，处理队列里的任务 SHUTDOWN 不接受新的任务，但处理队列里的任务 STOP 不接受新的任务，不处理队列里的任务，并且中断处理中的任务 TIDYING 所有任务已终止，工作线程数为0，转换为 TIDYING 状态，运行 terminated() 方法 TERMINATED terminated() 方法运行完成，线程池彻底终止","tags":["Java","线程池"]},{"title":"MySQL 范围查询索引问题探究","path":"/2024/05/11/MySQL 范围查询索引问题探究/","content":"在进行范围查询中，查询已经建立好索引的某个字段，会存在索引失效的情况。 假设有一张表 Test(id, A)，数据量为1000。在字段 A 上建立普通索引 idx_A 情况一1EXPLAIN SELECT * FROM `test` WHERE A &gt; 10; 利用 EXPLAIN 进行分析，type 为 ALL，说明进行了全表扫描 情况二1EXPLAIN SELECT * FROM `test` WHERE A &gt; 10; 利用 EXPLAIN 进行分析，type 为 range，说明用到了索引 情况三12EXPLAIN SELECT COUNT(*) FROM `test` WHERE A &lt; 10;EXPLAIN SELECT COUNT(*) FROM `test` WHERE A &gt; 10; 利用 EXPLAIN 进行分析，两条 SQL 的 type 为 range，说明都用到了索引 原因分析由于用到的是二级索引，需要进行回表查询才能获得索引数据，MySQL 的优化器会对语句进行优化，当查询的数据量大时，会采用全表扫描避免回表带来的开销。当数据量小时会使用索引并进行回表查询。 使用 COUNT(*) 统计数量时，无需回表查询，可以直接利用索引进行查询。"},{"title":"GET 和 POST 的区别","path":"/2024/05/08/GET 和 POST 的区别/","content":"深入聊聊 GET 和 POST 的区别 GET 和 POST 有什么区别？GET 的语义是从服务器上获取资源，比如文本、图片、页面等。参数一般写在 URL 中，URL 只支持 ASCII ，所以 GET 的参数只能是 ASCII 字符。浏览器对 URL 的长度有限制。 POST 的语义是根据请求负荷（body）对指定的资源做出处理。请求的参数写在报文 body 中，可以是任意格式，浏览器对 body 的大小不作限制 GET 和 POST 的安全性和幂等性 安全： 指请求方法不会对服务器的资源造成破坏幂等： 多次执行相同的操作，结果都相同 从 RFC 规范的语义上看： GET 方法是安全且幂等的，浏览器可以对 GET 请求的数据做缓存 POST 方法会修改服务器的资源且会根据参数的不同做出不同的操作，所以不安全也不幂等。大部分情况下不能够被缓存 浏览器请求方式GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包 对于 GET 请求，浏览器会把 header 和 data 一并发送出去，服务器响应 200（返回数据） 对于 POST 请求，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200（返回数据）","tags":["计算机网络","HTTP"]},{"title":"HTTPS 的那些事","path":"/2024/05/08/HTTPS 的那些事/","content":"概述HTTP 是超文本传输协议，是明文传输的，存在安全风险。HTTPS 解决了 HTTP 不安全的缺陷，在 TCP 和 HTTP 层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输 HTTPS 在 TCP 三次握手后，还需要进行 SSL/TLS 握手才能进行加密报文传输 HTTP 默认端口为 80，HTTPS 默认端口为 443 HTTPS 需要申请 CA 证书，来保证服务器的身份是可信的 客户端与服务端使用非对称加密将一个秘钥传递给对方，双方使用此秘钥通过对称加密通信。 HTTPS 的原理HTTP 由于是明文传输，存在监听、篡改、冒充等风险 HTTPS 如何解决以上风险？ 混合加密的方式实现信息的机密性，解决了窃听的风险。 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。 将服务器公钥放入到数字证书中，解决了冒充的风险。 1. 混合加密HTTPS 使用对称加密和非对称加密结合的混合加密方式： 在通信建立前采用非对称加密的方式来交换会话密钥 在通信过程中全部使用对称加密的会话密钥的方式加密明文数据 2. 摘要算法和数字签名3. 数字证书HTTPS 建立连接的过程","tags":["计算机网络","HTTP"]},{"title":"HTTP 1.1 介绍","path":"/2024/05/07/HTTP 1.1 介绍/","content":"概述 优点：简单、灵活、便于扩展、应用广泛 缺点 无状态 服务器无法关联操作 明文传输 不安全 使用明文传输，内容可能被窃听 无法验证通信方的身份 报文可能已经被篡改 HTTP/1.1 的性能HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在长连接和管道网络传输。 HTTP/1.1 的性能一般，后面的 HTTP/2 和 HTTP/3 都是在对 HTTP 进行性能优化。 长连接在 HTTP/1.0 时代，每次请求都需要重新建立 TCP 连接，增加了通信的消耗。 为了尽可能利用已经建立好的连接，HTTP/1.1 提出了长连接的通信方式，只要任意一端没有明确提出断开连接，则保存 TCP 连接状态。 当某个长连接超出一定时间没有数据交互时，服务器会主动断开连接。 管道网络传输管道机制就是运行客户端同时发送多个请求，不必等待前面请求的返回，可以减少整体的响应时间。 服务器必须按照接受请求的顺序来处理管道化的请求，如果某个请求 A 的耗时比较长，后续的请求都会被阻塞，称为队头阻塞。 HTTP/1.1 的管道机制解决了请求的队头阻塞，没有解决响应的对头阻塞 HTTP/1.1 管道技术不是默认开启的","tags":["计算机网络","HTTP"]},{"title":"为什么 TCP 是三次握手？","path":"/2024/05/06/为什么 TCP 是三次握手？/","content":"为什么 TCP 连接需要三次握手，不是两次，四次？ 基本原因：三次握手才能保证通信双方具备接收和发送的能力 下面分别展开深入分析。 使用三次握手的原因 阻止重复历史连接的初始化，避免资源浪费 同步双方的初始序列号，保证双方都具备接发的能力 避免历史连接 客户端希望与服务器建立连接，但是由于网络堵塞，发送了多个 SYN 报文： 旧的 SYN 报文（seq=90）先到达服务器，服务器返回 SYN+ACK 报文（ACK=91） 客户端期望收到的 ACK=101，不是 91，发送 RST 报文 服务器收到 RST 报文后，释放连接 等到最新的 SYN 报文（seq=100）到达服务器，正常进行三次握手 旧 SYN 报文成为历史连接。 使用两次握手？使用两次握手无法避免历史连接 假定使用两次握手，当服务器接收到一个 SYN 报文就建立连接，接下来可以发送数据。但是它不知道这是历史连接。当客户端感知到这是历史连接时，就会发送 RST 报文断开连接。这样会浪费服务器的资源。 使用四次握手？ 使用四次握手也能成功建立连接，但是第二步和第三步可以合并为一步，就变成了三次握手。"},{"title":"JS 高阶函数与函数柯里化","path":"/2024/05/05/JS 高阶函数与函数柯里化/","content":"高阶函数如果一个函数符合下面两个规范中的任何一个，那该函数就是高阶函数。 函数接收的参数是一个函数 函数调用后的返回值依然是一个函数 常见的高阶函数：Promise、setTimeout、arr.map() 等等 函数的柯里化通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式 1234567function sum(a) {\treturn (b) =&gt; { return (c) =&gt; { return a + b + c; }\t}}","tags":["JavaScript"]},{"title":"如何保证数据库和缓存的一致性","path":"/2024/05/05/如何保证数据库和缓存的一致性/","content":"先更新数据库，还是先更新缓存？当我们引入了缓存之后，在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在先后的问题。但在并发环境下，无论哪个先更新，都不能保证数据库和缓存的一致性。一般建议使用「先更新数据库，再删除缓存」的方案。 如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况。 针对并发导致的一致性问题，有两种解决方案： 在更新缓存前加个分布式锁，确保同一时间只有一个请求更新缓存。（会影响性能） 在更新缓存时给缓存加上较短的过期时间，即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务也能够接受。 Cacha Aside 旁路策略在更新数据时，不更新缓存，而是删除缓存中的数据。之后在读数据的时候，发现缓存中没有对应的数据，就去查数据库，并且更新到缓存中。 旁路策略可以细分为读策略和写策略： 写策略的步骤： 更新数据库 删除缓存 读策略的步骤： 如果读取的数据命中缓存，则直接返回数据 如果读取的数据没有命中，则从数据库中读取数据，然后将数据写入缓存，返回给用户 先删除缓存，再更新数据库假设请求 A 需要更新数据库，先删除缓存。这时请求 B 读取该数据，查询缓存没命中，从数据库读取到数据并且回写进缓存，然后请求 A 继续修改数据库，将对应数据更新。这时缓存和数据库中的数据不一致。 解决方案：延迟双删，请求 A 在更新完数据库后睡眠一段时间后再次删除缓存，确保请求 B 在 A 睡眠时间内完成所以操作 先更新数据库，再删除缓存假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中，出现缓存和数据库不一致的情况。 在实际中，缓存的写入远远快于数据库的写入，这个问题出现概率不大。可以给缓存加上过期时间来作为兜底策略。 删除缓存而不是更新缓存，是系统设计中懒加载思想的一个应用"},{"title":"React 学习笔记","path":"/2024/05/03/React 学习笔记/","content":"React 的特点 声明式编码 组件化编码 React Native 编写原生应用 高效（优秀的Diffing算法） React 为什么高效？ 使用了虚拟 DOM，不总是直接操作页面真是 DOM DOM Diffing 算法，最小化页面重绘 虚拟 DOM 与真实 DOM虚拟 DOM 本质上是一个 Object 对象，最终会被 React 转换为真实 DOM，渲染到界面上。 虚拟 DOM 比较轻量。 两种方式创建虚拟 DOM使用原生 JS(不推荐）： 1const VDOM = React.createElement('h1', {id: 'title'}, 'hello world') 使用 JSX（会通过 Babel 转化为 JS）： 1const VDOM = &lt;h1 id='title'&gt;hello world&lt;/h1&gt; 渲染虚拟 DOM将虚拟 DOM 渲染到页面中的真实容器 DOM 里 1React.render(VDOM, containerDOM) JSX 语法规则 定义虚拟DOM时，不用写引号 标签中混入JS表达式时要用{} 样式的类名指定要用 className 内联样式要用 style = {{key:value}} 的形式，使用驼峰命名法 虚拟 DOM 只能有一个根标签 标签必须闭合 标签首字母 小写字母开头，则将该标签转为 html 中的同名元素 大写字母开头，React 渲染对应的组件 面向组件编程函数式组件12345function Demo() {\treturn &lt;h2&gt;这是函数式组件&lt;/h2&gt;}// 注意 render 传的是组件标签ReactDOM.render(&lt;Demo/&gt;, document.getElementById(\"test\")); 类式组件类式组件必须继承 React.Component ，且具有 render() 方法 123456class Demo extends React.Component {\trender() { return &lt;h2&gt;这是类式组件&lt;/h2&gt;\t}}ReactDOM.render(&lt;Demo/&gt;, document.getElementById(\"test\")); 原理： 当执行 ReactDOM.render(&lt;Demo/&gt;.......) 之后，React 解析组件标签，找到了 Demo 组件。发现组件是使用类定义的，随后 new 出来该类的实例，并通过该实例调用到原型上的 render 方法。将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。 组件实例的三大核心属性statestate 属性用来表示组件的状态 state 属性只能通过 setState 函数更改，会与原先的 state 合并 state 示例1234567891011121314151617181920212223class Weather extends React.Component {\tconstructor(props) { super(props); // 初始化 state this.state = { isHot: true }; this.change = this.change.bind(this);\t}\trender() { const { isHot } = this.state; return ( // onClick 绑定事件，注意要使用驼峰命名法 &lt;h2 onClick={this.change}&gt; 今天天气：{this.state.isHot ? \"hot\" : \"cold\"} &lt;/h2&gt; );\t}\tchange() { // change 方法放在 Weather 的原型对象上 const isHot = this.state.isHot; this.setState({ isHot: !isHot });\t}}ReactDOM.render(&lt;Weather /&gt;, document.getElementById(\"test\")); 构造器中的 this 指向当前类的示例对象，render 方法通过类的实例调用，方法中的 this 也只想当前类的实例对象。 change 方法作为 onClick 的回调，并不是由类的实例调用，是直接调用。类中定义的方法自动开启了局部严格模式，故 this 为 undefined 可以通过 bind 函数将当前实例对象绑定到 change 上 state 的简写方式（推荐）一般类组件中的自定义方法（除了 render）是作为回调函数调用的，可以将方法写成赋值语句+箭头函数的形式。箭头函数会找它外层函数的 this 作为它本身的 this。 12345678910111213141516171819class Weather extends React.Component {\t// 初始化状态\tstate = {isHot: true} render() { const { isHot } = this.state; return ( &lt;h2 onClick={this.change}&gt; 今天天气：{this.state.isHot ? \"hot\" : \"cold\"} &lt;/h2&gt; );\t} change = () =&gt; { const isHot = this.state.isHot; this.setState({ isHot: !isHot });\t}}ReactDOM.render(&lt;Weather /&gt;, document.getElementById(\"test\")); props用于向组件传递数据，是只读的。 类式组件使用 props1234567891011121314151617181920212223242526class Person extends React.Component {\trender() { const { name, age, sex } = this.props; return ( &lt;ul&gt; &lt;li&gt;name: {name}&lt;/li&gt; &lt;li&gt;sex: {sex}&lt;/li&gt; &lt;li&gt;age: {age}&lt;/li&gt; &lt;/ul&gt; );\t}\t// 使用 static，给类添加属性\tstatic propTypes = { name: PropTypes.string.isRequired, // isRequired: 必需 age: PropTypes.number, sex: PropTypes.string, speak: PropTypes.func, // func: 函数\t};\t// 设定默认值\tstatic defaultProps = { name: \"ikun\",\t}; }ReactDOM.render(&lt;Person sex=\"0\" age={20}/&gt;, document.getElementById(\"test\")); 类式组件的构造器是否接收 props，是否传递给 super，取决于是否希望在构造器中通过 this 访问 props。一般情况下都不写构造器。 函数式组件使用 props函数式组件通过接收参数来传递 props 123456789101112131415161718192021222324function Person(props) {\tconst { name, sex, age } = props;\treturn ( &lt;ul&gt; &lt;li&gt;name: {name}&lt;/li&gt; &lt;li&gt;sex: {sex}&lt;/li&gt; &lt;li&gt;age: {age}&lt;/li&gt; &lt;/ul&gt;\t);}// 给组件添加属性Person.propTypes = {\tname: PropTypes.string.isRequired, // 必需\tage: PropTypes.number,\tsex: PropTypes.string,\tspeak: PropTypes.func,};// 设定默认值Person.defaultProps = {\tname: \"ikun\",};ReactDOM.render(&lt;Person sex=\"0\" age={20} /&gt;,document.getElementById(\"test\")); refs 与事件处理ref 用来标识某个标签，相当于原生标签中的 id，可以通过 this.refs 来获取到对应的真实 DOM 字符串形式的 ref存在效率问题，不推荐使用 12345678910111213141516class Demo extends React.Component {\tshow = () =&gt; { const {input} = this.refs; alert(input.value);\t}; render() { return ( &lt;div&gt; &lt;input ref=\"input\" type=\"text\" /&gt; &amp;nbsp; &lt;button onClick={this.show}&gt;click&lt;/button&gt; &lt;/div&gt; );\t}} 回调形式的 refref 传入一个回调函数，回调函数的参数就是当前 DOM 节点，React 会自动调用该回调函数，将该节点挂载到实例对象上。 12345678910111213141516class Demo extends React.Component {\tshow = () =&gt; { const {input} = this; alert(input.value);\t}; render() { return ( &lt;div&gt; &lt;input ref={c =&gt; this.input = c } type=\"text\" /&gt; &amp;nbsp; &lt;button onClick={this.show}&gt;click&lt;/button&gt; &lt;/div&gt; );\t}} 关于回调 refs 的说明如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 使用 createRef使用 React.createRef API 来创建一个容器，该容器可以存储被 ref 所标识的节点，一个容器只能放一个节点 1234567891011121314151617class Demo extends React.Component {\tmyRef = React.createRef(); show = () =&gt; { alert(this.myRef.current.value);\t}; render() { return ( &lt;div&gt; &lt;input ref={this.myRef} type=\"text\" /&gt; &amp;nbsp; &lt;button onClick={this.show}&gt;click&lt;/button&gt; &lt;/div&gt; );\t}} 注意事项避免过度使用 ref，建议使用受控组件，类似 Vue 中的双向绑定。 1234567891011class Demo extends React.Component {\tstate = { info: \"\" }; saveInfo = (e) =&gt; { this.setState({info: e.target.value})\t}\t// 通过onChange 将数据及时更新到 state 中\trender() { return &lt;input onChange={this.saveInfo} type=\"text\" /&gt;;\t}} 生命周期React 组件中包含一系列生命周期回调函数，会在特定的时刻调用 static getDerivedStateFromProps1static getDerivedStateFromProps(props, state) 从 props 中获得派生的状态，适用于 state 值在任何时候都取决于 props，一般不建议使用。 getSnapshotBeforeUpdate1getSnapshotBeforeUpdate(prevProps, prevState) 在最近一次渲染输出之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息。其返回值将作为参数传递给 componentDidUpdate() DOM 的 Diffing 算法在虚拟 DOM 渲染到页面上成为真实 DOM 之前会与旧的虚拟 DOM 进行对比，如果没有差异，就不会更新原先的真实 DOM，反之将虚拟 DOM 重新渲染到页面上。 虚拟 DOM 中的 key 的作用key 是虚拟 DOM 对象的标识 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟 DOM】，随后React 进行【新虚拟 DOM】与【旧虚拟 DOM】的 diff 比较 旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key： 若虚拟 DOM 中内容没变，直接使用之前的真实 DOM 若虚拟 DOM 中内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key，根据数据创建新的真实 DOM，随后渲染到到页面 用 index 作为 key 可能会引发的问题： 若对数据进行逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实 DOM 更新。虽然界面效果没问题, 但效率低。 如果结构中还包含输入类的 DOM，会产生错误 DOM 更新，界面有问题。 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。","tags":["React"]},{"title":"Java Comparator 接口的使用","path":"/2024/04/30/Java Comparator 接口的使用/","content":"很多情况下，我们需要对一个数组进行自定义排序，就可以使用 Comparator 接口。 Comparator 接口Comparator 接口的定义以及常用的方法如下： 123public interface Comparator&lt;T&gt; {\tint compare(T o1, T o2);} compare 方法用来比较两个对象的顺序，方法返回值有 3 种情况： o1 &lt; o2：返回 -1 o1 == o2：返回 0 o1 &gt; 02：返回 1 当返回结果为正数时，需要交换 o1，o2 的次序 示例使用 Comparator 接口对数组排序 1234567public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(3, 1, 2, 99, -1); // 使用了 lambda 表达式，从大到小排序 list.sort((a, b) -&gt; b - a); System.out.println(list); }// [99, 3, 2, 1, -1] 如果对两个 int 型变量进行判断，可以使用 Integer.compare(int a, int b) 如果 ，则返回 1 如果 ，则返回 -1 如果 ，则返回 0 如果使用 lambda 表达式 (a, b) -&gt; a - b 来判断大小，会存在整数溢出的问题导致判断错误.","tags":["Java"]},{"title":"小破站装修日记","path":"/2024/04/28/小破站装修日记/","content":"心路历程从上大学到现在，经历了两次电脑硬盘损坏，东西全部丢失，心态崩了。回想起我以前的存储习惯，并没有很好地整理和备份我的文档和资料。因此，我下定决心要改掉这个坏习惯，走出自己的舒适区，才能进步。 时间线 2024年4月29日 我的小破站终于成功上线了，并且利用 Github Action 实现了自动部署，同时将我的博客文档全都托管在 Github 仓库。小破站的主题是 stellar ，示例看起来非常不错，虽然当前的小破站还是毛坯房，等看看啥时间有空再来装修一下吧 hh。"}]