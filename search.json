[{"title":"React学习笔记","path":"/2024/05/04/React 学习笔记/","content":"React 的特点 声明式编码 组件化编码 React Native 编写原生应用 高效（优秀的Diffing算法） React 为什么高效？ 使用了虚拟 DOM，不总是直接操作页面真是 DOM DOM Diffing 算法，最小化页面重绘 虚拟 DOM 与真实 DOM虚拟 DOM 本质上是一个 Object 对象，最终会被 React 转换为真实 DOM，渲染到界面上。 虚拟 DOM 比较轻量。 两种方式创建虚拟 DOM使用原生 JS(不推荐）： 1const VDOM = React.createElement('h1', {id: 'title'}, 'hello world') 使用 JSX（会通过 Babel 转化为 JS）： 1const VDOM = &lt;h1 id='title'&gt;hello world&lt;/h1&gt; 渲染虚拟 DOM将虚拟 DOM 渲染到页面中的真实容器 DOM 里 1React.render(VDOM, containerDOM) JSX 语法规则 定义虚拟DOM时，不用写引号 标签中混入JS表达式时要用{} 样式的类名指定要用 className 内联样式要用 style = {{key:value}} 的形式，使用驼峰命名法 虚拟 DOM 只能有一个根标签 标签必须闭合 标签首字母 小写字母开头，则将该标签转为 html 中的同名元素 大写字母开头，React 渲染对应的组件 面向组件编程函数式组件12345function Demo() {\treturn &lt;h2&gt;这是函数式组件&lt;/h2&gt;}// 注意 render 传的是组件标签ReactDOM.render(&lt;Demo/&gt;, document.getElementById(\"test\")); 类式组件类式组件必须继承 React.Component ，且具有 render() 方法 123456class Demo extends React.Component {\trender() { return &lt;h2&gt;这是类式组件&lt;/h2&gt;\t}}ReactDOM.render(&lt;Demo/&gt;, document.getElementById(\"test\")); 原理： 当执行 ReactDOM.render(&lt;Demo/&gt;.......) 之后，React 解析组件标签，找到了 Demo 组件。发现组件是使用类定义的，随后 new 出来该类的实例，并通过该实例调用到原型上的 render 方法。将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。 组件实例的三大核心属性statestate 属性用来表示组件的状态 state 属性只能通过 setState 函数更改，会与原先的 state 合并 state 示例1234567891011121314151617181920212223class Weather extends React.Component {\tconstructor(props) { super(props); // 初始化 state this.state = { isHot: true }; this.change = this.change.bind(this);\t}\trender() { const { isHot } = this.state; return ( // onClick 绑定事件，注意要使用驼峰命名法 &lt;h2 onClick={this.change}&gt; 今天天气：{this.state.isHot ? \"hot\" : \"cold\"} &lt;/h2&gt; );\t}\tchange() { // change 方法放在 Weather 的原型对象上 const isHot = this.state.isHot; this.setState({ isHot: !isHot });\t}}ReactDOM.render(&lt;Weather /&gt;, document.getElementById(\"test\")); 构造器中的 this 指向当前类的示例对象，render 方法通过类的实例调用，方法中的 this 也只想当前类的实例对象。 change 方法作为 onClick 的回调，并不是由类的实例调用，是直接调用。类中定义的方法自动开启了局部严格模式，故 this 为 undefined 可以通过 bind 函数将当前实例对象绑定到 change 上 state 的简写方式（推荐）一般类组件中的自定义方法（除了 render）是作为回调函数调用的，可以将方法写成赋值语句+箭头函数的形式。箭头函数会找它外层函数的 this 作为它本身的 this。 12345678910111213141516171819class Weather extends React.Component {\t// 初始化状态\tstate = {isHot: true} render() { const { isHot } = this.state; return ( &lt;h2 onClick={this.change}&gt; 今天天气：{this.state.isHot ? \"hot\" : \"cold\"} &lt;/h2&gt; );\t} change = () =&gt; { const isHot = this.state.isHot; this.setState({ isHot: !isHot });\t}}ReactDOM.render(&lt;Weather /&gt;, document.getElementById(\"test\")); props用于向组件传递数据 refs 与事件处理"},{"title":"Java Comparator 接口的使用","path":"/2024/04/30/Java Comparator 接口的使用/","content":"很多情况下，我们需要对一个数组进行自定义排序，就可以使用 Comparator 接口。 Comparator 接口Comparator 接口的定义以及常用的方法如下： 123public interface Comparator&lt;T&gt; {\tint compare(T o1, T o2);} compare 方法用来比较两个对象的顺序，方法返回值有 3 种情况： o1 &lt; o2：返回 -1 o1 == o2：返回 0 o1 &gt; 02：返回 1 当返回结果为正数时，需要交换 o1，o2 的次序 示例使用 Comparator 接口对数组排序 1234567public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(3, 1, 2, 99, -1); // 使用了 lambda 表达式，从大到小排序 list.sort((a, b) -&gt; b - a); System.out.println(list); }// [99, 3, 2, 1, -1]"},{"title":"小破站装修日记","path":"/2024/04/28/小破站装修日记/","content":"心路历程从上大学到现在，经历了两次电脑硬盘损坏，东西全部丢失，心态崩了。回想起我以前的存储习惯，并没有很好地整理和备份我的文档和资料。因此，我下定决心要改掉这个坏习惯，走出自己的舒适区，才能进步。 时间线 2024年4月29日 我的小破站终于成功上线了，并且利用 Github Action 实现了自动部署，同时将我的博客文档全都托管在 Github 仓库。小破站的主题是 stellar ，示例看起来非常不错，虽然当前的小破站还是毛坯房，等看看啥时间有空再来装修一下吧 hh。"}]